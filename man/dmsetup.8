.TH DMSETUP 8 "Nov 29 2001" "Linux" "MAINTENTANCE COMMANDS"
.SH NAME
dmsetup \- low level logical volume management
.SH SYNOPSIS
.ad l
.B dmsetup create
.I device_name table_file [uuid]
.br
.B dmsetup remove
.I device_name
.br
.B dmsetup rename
.I device_name new_name
.br
.B dmsetup suspend
.I device_name
.br
.B dmsetup resume
.I device_name
.br
.B dmsetup reload
.I device_name table_file
.br
.B dmsetup info
.I device_name
.br
.B dmsetup deps
.I device_name
.br
.B dmsetup status
.I device_name
.br
.B dmsetup table
.I device_name
.br
.B dmsetup wait
.I device_name
.br
.B dmsetup remove_all
.I device_name
.br
.B dmsetup version
.ad b
.SH DESCRIPTION
dmsetup manages logical devices that use the device-mapper driver.  
Devices are created by loading a table that specifies a target for
each sector in the logical device.

The first argument to dmsetup is a command. 
The second argument is the logical device name or uuid.
.SH COMMANDS
.IP \fBcreate
.I device_name table_file [uuid]
.br
Attempts to create a device using the table file given.
The optional uuid can be used in place of
device_name in subsequent dmsetup commands.  If
successful a device will appear as
/dev/device-mapper/<device-name>.  See below for information
on the table file format.
.IP \fBremove
.I device_name
.br
Removes a device
.IP \fBrename
.I device_name new_name
.br
Renames a device
.IP \fBsuspend
.I device_name
.br
Suspends a device.  Any I/O that has already been mapped by the device
but has not yet completed will be flushed.  Any further I/O to that
device will be postponed for as long as the device is suspended.
.IP \fBresume
.I device_name
.br
Un-suspends a device.  Postponed I/O now gets re-queued for processing.
.IP \fBreload
.I device_name table_file
.br
This command will only work if a device is in the suspended state.
It changes the mapping table for an existing device.
.IP \fBinfo
.I device_name
.br
Outputs some brief information about the device in the form:
.br
    SUSPENDED|ACTIVE
.br
    open_count
.br
    major,minor
.br
    target_count
.IP \fBdeps
.I device_name
.br
Outputs a list of (major, minor) pairs for devices referenced by the
specified device.
.IP \fBstatus
.I device_name
.br
Outputs status information for each of the device's targets.
.IP \fBtable
.I device_name
.br
Outputs the current table for the device in a format than can be fed
back in using the create or reload commands.
.IP \fBwait
.I device_name
.br
Sleeps until an event is triggered against a device.
.IP \fBremove_all
.br
Attempts to remove all device definitions i.e. reset the driver.
Use with care!
.IP \fBversion
.I device_name
.br
Outputs version information.
.SH TABLE FORMAT
Each line of the table specifies a single target and is of the form:
.br
    logical_start_sector num_sectors target_type target_args
.br
.br
There are currently three simple target types available together 
with more complex optional ones that implement snapshots and mirrors.

.IP \fBlinear
.I destination_device start_sector
.br
The traditional linear mapping.

.IP \fBstriped
.I num_stripes chunk_size [destination start_sector]+
.br
Creates a striped area.
.br
e.g. striped 2 32 /dev/hda1 0 /dev/hdb1 0
will map the first chunk (16k) as follows:
.br
    LV chunk 1 -> hda1, chunk 1
.br
    LV chunk 2 -> hdb1, chunk 1
.br
    LV chunk 3 -> hda1, chunk 2
.br
    LV chunk 4 -> hdb1, chunk 2
.br
    etc.


.IP \fBio-err
.br
Errors any I/O that goes to this area.  Useful for testing or
for creating devices with holes in them.


.SH EXAMPLES


# A table to join two disks together
.br
.br
0 1028160 linear /dev/hda 0
.br
1028160 3903762 linear /dev/hdb 0



# A table to stripe across the two disks, 
.br
# and add the spare space from
.br
# hdb to the back of the volume

0 2056320 striped 2 32 /dev/hda 0 /dev/hdb 0
.br
2056320 2875602 linear /dev/hdb 1028160

.SH AUTHORS
Original version: Joe Thornber (thornber@sistina.com)
